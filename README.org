* Ttl

** What

*** Good
The beautiful thing about org-mode is the customizability. 
 - org-agenda
 - org-habit
 - org-capture
 - org-journal
 - org-contacts
 - timetracking
 - tables / spreadsheet
 - org-pomodoro
 - org-wiki
 - org-brain
 - org-present?
 - calendar invites
 - export to html/etc.
 - fold / unfold
 - scheduling with other people
 
Acts as an agenda, outliner, wiki, blog, etc. It's secure because single-user. Easy to backup, etc. The best of all worlds if there is only a single device.

*** Bad
1) Cannot easily capture web data, pictures, video, clips, etc.
2) Not simple/easy to access over mobile. Though there are mobileorg and orgzly. 
3) Collaboration (though will need to think about security model here)
   - Whether through publishing blog, document
   - Allowing sharing / delegation of tasks
   - Comments 

*** How
- Capture
- Schedule the time to do it.

- Goals / things / tasks that want to accomplish
- Countdown the number of days to accomplish 
- Get reminded
- Encouragement from others who have the same goal
- Markdown?
- Reminder / categorization - groceries, etc based on location
  - Notifications 
    - https://github.com/realtime-framework/WebPushNotifications/blob/master/index.js
    - https://pushcrew.com/pricing/
    - https://gauntface.github.io/simple-push-demo/
    - https://github.com/GoogleChrome/samples/tree/gh-pages/push-messaging-and-notifications
    - https://github.com/web-push-libs/web-push-php
    - https://elixirforum.com/t/what-is-the-simplest-way-to-send-notification-from-elixir-app-to-android-device/6264/4

Object/Item/Task (this is the fundamental unit - could be part of goal or habit)
  - UserId
  - ObjectId
  - GoalId maybe null
  - HabitId maybe null
  - ReferenceId (jira, email, picture, note, outlook, integrations, comments)
  - Attachments
  - Properties (likable, commentable, private, etc)
  - Path - in case there are many subtasks
  - Blob
  - Minimum time needed
  - Time spent
  - Time left
  - State
  - Times deferred

This becomes an adventure in either parsing the document and storing everything as one item. Or having to parse the document itself.

Goals
  - Habit (streak based)
  - Time limit
    - Weekly
    - 40 days (short)
    - 6 months (medium)
    - 1 year (long)
  - Success criteria?
  - Could be suggested
  - Breakdown Items + Time
  - Weekly review
  - Reward
  - Start Date
  - End Date

Interaction
  - Comments
  - Reaction (time, parent, author)

Prioritizer
  - bin-packing based on min-time, deadline, priority
  - Every x-y days
  - Schedule
  - Deadline
  - Priority
  - Prior scheduling that worked and was successful
  - Saves the event and the suggestion

Groups
  - set of users
  - topics
  - interactions

Interaction
  - ObjectId
  - UserId
  - Comments
  - Reaction (time, parent, author)

Journal
  - day
  - rating
  - frequency

Open Times
  - UserId
  - Calendar
  - Scheduling
  - Tags associated with times
  - Enum(Tagged - will schedule with tag, Open)

  - Calendar implementation:
    - user_id + template
    - template:
      - { day, date, time, type={"base", "override"}, tag={"work", "sleep", etc} }
      - {[1-5], nil, [9-17], "base", "work"}
      - {[1-5], nil, [8-830], "base", "commute"}
      - {[1-5], nil, [1630-1730], "base", "commute"}
      - {nil, 2017-07-04, nil, type="override", tag={"offday"}


Tags
  - project (assoc with work)
  - podcast (assoc with any)
  - gardening (assoc with home)
  - woodworking (assoc with home)
  - health (assoc with any)
  - meditation (assoc with home)
  - reading (assoc with any)
  - writing (assoc with any)
  - hiking (assoc with offday)

Context
  - bus
  - home
  - work
  - in transport
  - offday

State:
  - stuck
  - delay
  - 5min
  - done
  - open
  - started


Others:
https://checkvist.com/checklists/627469-name-your-project-and-press-enter
https://workflowy.com/ -- the most mature app
https://www.moo.do -- really nice Google Apps integration
https://checkvist.com/ -- extremely feature rich
https://github.com/novoid/Memacs
https://turtlapp.com/
http://www.makeuseof.com/tag/lightweight-onenote-evernote-alternatives/

    
  

** Workflow:
*** Sync 
This will send the entire file over and at high load and high users cause issues. Will need a emacs client to update properties. 

- Have things locally.
- Initial sync
- Server parses and adds uuid's
  - Stores in database so can do scheduling, sharing, making lists for other people
  - Re-exports with additional property information
- No conflict resolution between local/remote copies.
  Should have a time-vector on each element though.
  Pull down any changes from server and use them. Sync to server overwrites the uploads/changes.
- This workflow requires an api:
  - Import/export whole documents (this can be used by emacs and/or the web editor)

*** Collaboration
A simple use case is someone making a list for someone else to do. Grocery list, etc. 
When is something allowed to be delegated? What are the viewing permissions? Are there spaces with permissions/groups instead? 
Commenting then can be on objects as a generic comment service. However, how would the comments be fetched? They would have to have the same permissions as the parent. Don't want the comment service to have to call back to the parent service for permissions. The other option is replicating / synchronizing the permissions over the the comment system. Another option is only have trusted systems call the comment system and never have it public.    
*** Capturing
Major issue is capturing images, bookmarks, webpages. 

https://github.com/alphapapa/org-protocol-capture-html has some bookmarklets. 

** MVP
*** Thoughts on parsing and db schema:
  - Can store the entire file and then the tags/headers in separate tables for scheduling
    - If the agenda is modified on web, item state to done, the file needs to be re-written also. Need to keep both in sync.
  - Represent the entire file as an AST and then store it
    - AST table (how to deal with deleted fragments?)
      - doc | [element_paths, uuid1, uuid2, uuid3]  -> export selects and joins all the elements in the path?
        object | [ uuid, uid, gid, content ]
      - how to represent header levels, planning, property, then all the stuff under the header?
      - [header(level=1, uuid=x, planning, property), section(uuid=x, content), header(level=2, uuid=x, planning, property)
      - how to represent a list with tags and without tags?
        - answer: don't. adds complications for now and no point
      - how to collaborate? have another field with users that have access/edit to it? treat each object as a gco
      - associated with a single object - header, planning, properties, section, timelog
      - timelog should have the logbook and the state transitions? or separate tables?
  #+NAME: DBSCHEMA
  - Database schema

     #mix phx.gen.html Things Document documents user_id:references:accounts_users name:string objects:array:uuid:references_things_objects
     mix phx.gen.html Things Document documents user_id:references:accounts_users name:string objects:array:uuid
   
     mix phx.gen.html Things Object objects document_id:references:things_documents path:array:uuid level:integer title:text content:text blob:binary closed:utc_datetime scheduled:utc_datetime deadline:utc_datetime state:string priority:string version:integer defer_count:integer min_time_needed:integer time_spent:integer time_left:integer permissions:integer

     mix phx.gen.html Things Tag tags user_id:references:accounts_users tag:string

     Maybe add a type column to these and call it a day?
     mix phx.gen.html Things Property properties object_id:references:things_objects key:string value:string
     mix phx.gen.html Things Timelog timelogs object_id:references:things_objects key:string value:string
 
     create many to many table things_objects_tags
     create many to many table things_objects_properties

     A document is an array of objects, a header has properties, tags, logbook associated with it, and section. Could also make it more of a tree-like structure, but we're not trying to edit the document, we're trying to get the main parts to do some scheduling and be able to regenerate it.

     An annoying problem is that we want to be able to refresh a document and also reorder or remove any objects. Possible to have a table of UUID's in the document to guarantee order. Another possibility is a many table with reference to document. If objects moved up and down, we would have to update every object. Same for insertion for new objects in the middle of a file. With an array of uuid's, need to just update the array and take care of fragments later. 


      


    - old notes header is essentially an object, but then what is a section? section will be the content of a header
      what about logbook?

    if we want to get a subtree, we also need to put in the path correctly for the subtree
    or can generate subtree - from the doc uuid's

  - how to get a particular ordered subtree of a document?
    we should have a document with a set of uuid's in an order. we need to select up to the last uuid where level = the level we're at
    CREATE EXTENSION pgcrypto; 
    CREATE TABLE contacts(  id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name TEXT, email TEXT);

    snw=# with x (id_list) as ( values (array['bb8f6873-b2f7-4109-a35f-308930e1d57c', '3ccd8a17-0fac-484c-83ab-feacf88c1812', '2eb23b9f-eb9d-40d0-a46a-24c50aa73173'])) select c.* from contacts c, x where cast(id as text) = any (x.id_list) order by array_position(x.id_list, cast( c.id as text));
    id                  |      name       | email 
    --------------------------------------+-----------------+-------
    bb8f6873-b2f7-4109-a35f-308930e1d57c | Geoff Franks    | geoff
    3ccd8a17-0fac-484c-83ab-feacf88c1812 | Dr Nic Williams | drnic
    2eb23b9f-eb9d-40d0-a46a-24c50aa73173 | Jamie Van Dyke  | jamie

  - ttl_dev=# with x (id_list) as ( values (array['ffce2bd3-a4c4-4ea9-98df-e4ebde4452ee','75c3758c-0af9-4f15-a75a-c66a2fbe0299','f3c99da2-f9ef-45d8
-a59d-c2b606be52d6'])) select o.id, o.title from things_objects o, x where cast(id as text) = any (x.id_list) order by array_position(x.id_list
, cast( o.id as text));  
  - with x (id_list) as (select objects from things_documents) select o.id, o.title from things_objects o, x where id = any (x.id_list) order by array_position(x.id_list, o.id );



*** Thoughts on UI Interface

- If this is for power-users, it has to be able to integrate with org-mode. To import/export out of text mode, there needs to be a UUID for each element.

- If tasks can be shared / commented / etc. each item will have to be independent. Also, inheritance is important here, probably just from the top-level. 
- How would conflict resolution be handled? Not sure how to merge diffs between different versions except to have a time-clock.

- https://org-web.org/ - is a rudimentary org-web parser
- http://appsonthemove.com/blog/2017/05/25/borg/
- http://www.orgzly.com/help#org7fa55de
- https://www.reddit.com/r/emacs/comments/6r5htr/capturing_short_notes_on_the_go_then_sync_to_org/


*** import/export to api. 
**** DONE write a parser (not going to do in elisp since may want non-emacs users)
     CLOSED: [2017-08-15 Tue 18:27]
**** DONE create db schema
CLOSED: [2017-08-13 Sun 15:01]
[[DBSCHEMA]]
**** DONE consolidate sections
CLOSED: [2017-08-13 Sun 15:00]
:LOGBOOK:
CLOCK: [2017-08-13 Sun 12:14]--[2017-08-13 Sun 12:39] =>  0:25
CLOCK: [2017-08-13 Sun 11:44]--[2017-08-13 Sun 12:09] =>  0:25
CLOCK: [2017-08-13 Sun 11:14]--[2017-08-13 Sun 11:39] =>  0:25
CLOCK: [2017-08-13 Sun 07:18]--[2017-08-13 Sun 07:44] =>  0:26
CLOCK: [2017-08-13 Sun 06:46]--[2017-08-13 Sun 07:12] =>  0:26
:END:
**** DONE Need to fix the planning parser to grab the dates
CLOSED: [2017-08-13 Sun 15:00]
:LOGBOOK:
CLOCK: [2017-08-13 Sun 12:48]--[2017-08-13 Sun 13:13] =>  0:25
:END:
**** DONE consolidate header (property, planning)
CLOSED: [2017-08-13 Sun 15:00]
**** DONE implement db schema
CLOSED: [2017-08-14 Mon 16:44]
:LOGBOOK:
CLOCK: [2017-08-14 Mon 16:14]--[2017-08-14 Mon 16:39] =>  0:25
CLOCK: [2017-08-14 Mon 15:44]--[2017-08-14 Mon 16:09] =>  0:25
CLOCK: [2017-08-14 Mon 15:09]--[2017-08-14 Mon 15:34] =>  0:25
:END:
**** DONE write to database
     CLOSED: [2017-08-15 Tue 21:48]
:LOGBOOK:
CLOCK: [2017-08-15 Tue 11:13]--[2017-08-15 Tue 11:38] =>  0:25
CLOCK: [2017-08-15 Tue 10:44]--[2017-08-15 Tue 11:09] =>  0:25
CLOCK: [2017-08-15 Tue 10:14]--[2017-08-15 Tue 10:39] =>  0:25
CLOCK: [2017-08-15 Tue 09:44]--[2017-08-15 Tue 10:09] =>  0:25
CLOCK: [2017-08-15 Tue 09:11]--[2017-08-15 Tue 09:36] =>  0:25
CLOCK: [2017-08-14 Mon 19:26]--[2017-08-14 Mon 19:46] =>  0:20
CLOCK: [2017-08-14 Mon 18:57]--[2017-08-14 Mon 19:26] =>  0:29
CLOCK: [2017-08-14 Mon 18:31]--[2017-08-14 Mon 18:56] =>  0:25
CLOCK: [2017-08-14 Mon 18:05]--[2017-08-14 Mon 18:30] =>  0:25
CLOCK: [2017-08-14 Mon 17:13]--[2017-08-14 Mon 17:38] =>  0:25
CLOCK: [2017-08-14 Mon 16:44]--[2017-08-14 Mon 17:10] =>  0:26
:END:
The dates need to be parsed to put into the db
Turns out they are of many variable formats, need to use regexp
The scheduler needs to have a few additional fields in db

After mucking around quite a bit with dates, regret not using a lexer. 
Turns out Ecto casting from naive datetime to datetime was the issue. 

Takes a document, parses it, and can insert all the objects into the database

***** DONE Make it into a function 
      CLOSED: [2017-08-15 Tue 20:06]
      :LOGBOOK:
      CLOCK: [2017-08-15 Tue 19:30]--[2017-08-15 Tue 20:00] =>  0:30
      :END:
***** DONE Make a solid decision on what to do on failed update / version conflict
      CLOSED: [2017-08-15 Tue 21:40]
      :LOGBOOK:
      CLOCK: [2017-08-15 Tue 21:00]--[2017-08-15 Tue 21:38] =>  0:38
      CLOCK: [2017-08-15 Tue 20:13]--[2017-08-15 Tue 20:38] =>  0:25
      :END:
***** DONE Parse and cast the dates
      CLOSED: [2017-08-15 Tue 18:19]
      http://orgmode.org/manual/Timestamps.html#Timestamps

      :LOGBOOK:
      CLOCK: [2017-08-15 Tue 16:55]--[2017-08-15 Tue 18:14] =>  1:19
      CLOCK: [2017-08-15 Tue 16:15]--[2017-08-15 Tue 16:51] =>  0:36
      CLOCK: [2017-08-15 Tue 15:30]--[2017-08-15 Tue 16:11] =>  0:41
      CLOCK: [2017-08-15 Tue 15:04]--[2017-08-15 Tue 15:29] =>  0:25
      CLOCK: [2017-08-15 Tue 13:25]--[2017-08-15 Tue 13:50] =>  0:25
      CLOCK: [2017-08-15 Tue 12:43]--[2017-08-15 Tue 13:25] =>  0:42
      CLOCK: [2017-08-15 Tue 12:16]--[2017-08-15 Tue 12:41] =>  0:25
      CLOCK: [2017-08-15 Tue 11:43]--[2017-08-15 Tue 12:08] =>  0:25
      :END:
***** DONE Or maybe need to do versioning right now?
      CLOSED: [2017-08-15 Tue 18:22]
**** DONE Need to parse the file metadata
     CLOSED: [2017-08-15 Tue 23:18]
      CLOCK: [2017-08-15 Tue 21:45]--[2017-08-15 Tue 23:20] =>  1:40
written to the database as jsonb
http://ehneilsen.net/notebook/orgExamples/org-examples.html#sec-2

**** DONE regenerate file from database - with uuid's
     CLOSED: [2017-08-16 Wed 19:18]
     :LOGBOOK:
     CLOCK: [2017-08-16 Wed 18:45]--[2017-08-16 Wed 19:20] =>  0:35
     CLOCK: [2017-08-16 Wed 18:15]--[2017-08-16 Wed 18:40] =>  0:25
     CLOCK: [2017-08-16 Wed 17:40]--[2017-08-16 Wed 18:15] =>  0:35
     CLOCK: [2017-08-16 Wed 17:10]--[2017-08-16 Wed 17:38] =>  0:28
     CLOCK: [2017-08-16 Wed 16:40]--[2017-08-16 Wed 17:08] =>  0:28
     CLOCK: [2017-08-16 Wed 16:11]--[2017-08-16 Wed 16:36] =>  0:25
     CLOCK: [2017-08-16 Wed 12:03]--[2017-08-16 Wed 12:28] =>  0:25
     CLOCK: [2017-08-16 Wed 11:28]--[2017-08-16 Wed 11:53] =>  0:25
     CLOCK: [2017-08-16 Wed 11:05]--[2017-08-16 Wed 11:20] =>  0:15
     CLOCK: [2017-08-16 Wed 10:36]--[2017-08-16 Wed 11:01] =>  0:25
     CLOCK: [2017-08-16 Wed 08:45]--[2017-08-16 Wed 09:00] =>  0:15
     CLOCK: [2017-08-16 Wed 07:25]--[2017-08-16 Wed 07:43] =>  0:18
     :END:
    - The file uuid goes in the metadata at the top
    - The object metadata goes into properties
    - ttl_dev=# with x (id_list) as (select objects from things_documents) select o.id, o.title from things_objects o, x where id = any (x.id_list) order by array_position(x.id_list, o.id  );
    - ttl_dev=# with x (id_list) as (select objects from things_documents) select o.id, o.title from things_objects o, d.metadata from things_documents d,  x where id = any (x.id_list) order by array_position(x.id_list, o.id  );
    - 
***** DONE adjust the levels for files with no bullets to 0 - this will fix for files with no headline
      CLOSED: [2017-08-16 Wed 07:22]
***** DONE bug with closed planning data not being parsed
      CLOSED: [2017-08-16 Wed 07:43]

**** DONE Bugs - adil file has extra newline at start
     CLOSED: [2017-08-16 Wed 19:18]
**** DONE Properties - parse, store, and write
     CLOSED: [2017-08-16 Wed 22:59]
     :LOGBOOK:
     CLOCK: [2017-08-16 Wed 21:10]--[2017-08-16 Wed 22:57] =>  1:47
     :END: 
**** DONE Add file uuid into regenerate
     CLOSED: [2017-08-16 Wed 23:39]
**** DONE Add version and id into regenerated object 
     CLOSED: [2017-08-17 Thu 00:03]
     :LOGBOOK:
     CLOCK: [2017-08-16 Wed 23:39]--[2017-08-17 Thu 00:03] =>  0:24
     :END:
**** DONE Read file uuid from file to pull objects
     CLOSED: [2017-08-17 Thu 11:38]
     :LOGBOOK:
     CLOCK: [2017-08-17 Thu 10:00]--[2017-08-17 Thu 10:57] =>  0:57
     CLOCK: [2017-08-17 Thu 08:55]--[2017-08-17 Thu 09:20] =>  0:25
     CLOCK: [2017-08-17 Thu 08:05]--[2017-08-17 Thu 08:50] =>  0:45
     :END:
**** DONE Start of file exception
     CLOSED: [2017-08-17 Thu 11:38]
     :LOGBOOK:
     CLOCK: [2017-08-17 Thu 11:04]--[2017-08-17 Thu 11:29] =>  0:25
     :END:
**** DONE Ensure data gets updated on change
     CLOSED: [2017-08-17 Thu 13:05]
     :LOGBOOK:
     CLOCK: [2017-08-17 Thu 12:58]--[2017-08-17 Thu 13:06] =>  0:08
     :END:
      Org-mode won't ever update the version locally. If remote_version > local_version => conflict.
      Conflict resolution will require parsing things locally and replacing them
      Tests:
       - An old object (all db counts same)
       - A new object gets added (db count + 1)
       - the new object gets modified (db count same)

**** DONE make an interval data structure for schedule parsing and bin-packing calendar with contexts / tags
     CLOSED: [2017-08-17 Thu 17:53]
     :LOGBOOK:
     CLOCK: [2017-08-19 Sat 11:12]--[2017-08-19 Sat 11:37] =>  0:25
     CLOCK: [2017-08-19 Sat 10:37]--[2017-08-19 Sat 11:02] =>  0:25
     CLOCK: [2017-08-17 Thu 13:42]--[2017-08-17 Thu 14:07] =>  0:25
     :END:
Time can be tagged with multiple contexts. So an interval of time can be tagged work, etc. 
org-mode also has intervals which need to be stored for scheduled time and repetition. 
      CLOSED: [2016-06-02 Thu 21:22] SCHEDULED: <2016-06-08 Wed 09:00+x>--<2016-06-02 9:00-17:00> DEADLINE: <bla>

The agenda display is not important in this case, the api output will need to be generated anyway. 
Easiest format for a single day would be {start_time, interval_size}. This allows for packing things into whatever interval_size available. 
The end times for org-document generation will need to be calculated.  
For the issue of "scheduled" over multiple days, it will need to become a list. [{start_time1, interval1}, {start_time2, interval2}] and repeat_interval
In the db - not sure how to store this? another jsonb?
Use two arrays - one for start time, the other for interval. 
Other option - just have a planning table. 
select * from objects o, planning p where o.id = p.object_id and p.scheduled > $p1 and p.scheduled < $p2 

UPDATE - just going with start_time, start_interval, date_range

     mix phx.gen.html Things Object objects document_id:references:things_documents path:array:uuid level:integer title:text content:text blob:binary state:string priority:string version:integer defer_count:integer min_time_needed:integer time_spent:integer time_left:integer permissions:integer
     mix phx.gen.html Things Planning planning object_id:references:things_objects repeat_interval:string closed:utc_datetime scheduled:utc_datetime scheduled_date_range:integer scheduled_time_interval:integer deadline:utc_datetime 
     mix phx.gen.html Things Property properties object_id:references:things_objects key:string value:string
     mix phx.gen.html Things Timelog timelogs object_id:references:things_objects key:string value:string

Workflow:
Server sees free time. Sorts by priority + tag matching on time slot + longest first? Need to optimize algorithm based on actual results. 
Yes/no -> deferred -> repeat.  
Or set out a full schedule at night. 
Data structure is fine. 
However, need ability to defer scheduled tasks and logging.


**** DONE Parse the schedule properly into the interval structure
     CLOSED: [2017-08-19 Sat 17:53]
     :LOGBOOK:
     CLOCK: [2017-08-17 Thu 18:55]--[2017-08-17 Thu 19:20] =>  0:25
     CLOCK: [2017-08-17 Thu 18:25]--[2017-08-17 Thu 18:50] =>  0:25
     CLOCK: [2017-08-17 Thu 17:53]--[2017-08-17 Thu 18:20] =>  0:27
     :END:
Current state - schedule start_date parsing has been done. End_date, duration, repeat_interval remain. Data structure needs put into schema and then populated.

 
**** DONE Bugs parsing schedule time interval + repeat - is this done later?
     CLOSED: [2017-08-19 Sat 17:53]
**** Bugs regeneration date format should be the same
**** Parse or skip logbook 
      - probably a separate table. Same as tags. Did insert_all with ecto which may complicate this implementation
**** Compare the objects 
      - Need to modify the object from ui/db and then test uploads
**** Add REST api?
      Start off with a simple curl client to do whole files
      Later can make an object level api and make an elisp client - update versions / conflict resolution
*** display UI for agenda
- https://www.realsimple.com/home-organizing/organizing/bullet-journal
- http://help.bulletjournal.com/category/5-bullet-journaling-101
- https://news.ycombinator.com/item?id=11856987
- http://talk.dynalist.io/t/switching-to-dynalist-from-workflowy-and-todoist/475
- memex - what did you do on what day
- reminder to journal
*** Security
https://turtlapp.com/
https://standardnotes.org/blog/7/announcing-our-2017-security-audit-results
https://github.com/standardfile
*** parse additional properties for scheduling + contexts + tags
*** notifications
*** capture
- some sort of ifttt integration? send email to an interface and it will go into todo?
*** Cleanup
**** use ecto.multi or control the dual commit transaction
**** Move anon functions into modules. Add spec to each one
**** Tests
       Updates
       - An old object (all db counts same)
       - A new object gets added (db count + 1)
       - the new object gets modified (db count same)

* Scratch

#+BEGIN_SRC elixir :results output
2 + 2
#+END_SRC

* clocktable
#+BEGIN: clocktable :maxlevel 5 :scope file
#+CAPTION: Clock summary at [2017-08-18 Fri 00:02]
| Headline                                         | Time      |         |         |       |      |
|--------------------------------------------------+-----------+---------+---------+-------+------|
| *Total time*                                     | *1d 4:00* |         |         |       |      |
|--------------------------------------------------+-----------+---------+---------+-------+------|
| Ttl                                              | 1d 4:00   |         |         |       |      |
| \_  MVP                                          |           | 1d 4:00 |         |       |      |
| \_    import/export to api.                      |           |         | 1d 4:00 |       |      |
| \_      consolidate sections                     |           |         |         |  2:07 |      |
| \_      Need to fix the planning parser to...    |           |         |         |  0:25 |      |
| \_      implement db schema                      |           |         |         |  1:15 |      |
| \_      write to database                        |           |         |         | 11:06 |      |
| \_        Make it into a function                |           |         |         |       | 0:30 |
| \_        Make a solid decision on what to do... |           |         |         |       | 1:03 |
| \_        Parse and cast the dates               |           |         |         |       | 4:58 |
| \_      Need to parse the file metadata          |           |         |         |  1:35 |      |
| \_      regenerate file from database - with...  |           |         |         |  4:59 |      |
| \_      Properties - parse, store, and write     |           |         |         |  1:47 |      |
| \_      Add version and id into regenerated...   |           |         |         |  0:24 |      |
| \_      Read file uuid from file to pull objects |           |         |         |  2:07 |      |
| \_      Start of file exception                  |           |         |         |  0:25 |      |
| \_      Ensure data gets updated on change       |           |         |         |  0:08 |      |
| \_      make an interval data structure for...   |           |         |         |  0:25 |      |
| \_      Parse the schedule properly into the...  |           |         |         |  1:17 |      |
#+END:
